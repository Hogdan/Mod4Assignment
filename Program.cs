using NLog;
string path = Directory.GetCurrentDirectory() + "//nlog.config";

// Configure logger
var logger = LogManager.Setup()
    .LoadConfigurationFromFile(path)
    .GetCurrentClassLogger();

logger.Info("Program started");

// Variables
string file = "mario.csv";
string? choice;

// Exception handling
if (!File.Exists(file))
{
    // errors now handled with logger
    logger.Error("Error: {0} not found", file);
}
else
{
    // Parallel lists for each column in the csv file
    List<UInt64> ids = [];
    List<string> names = [];
    List<string> descriptions = [];
    List<string> species = [];
    List<string> firstAppearances = [];
    List<string> yearsCreated = [];

    // Read data from file and populate lists
    try
    {
        StreamReader sr = new(file);
        sr.ReadLine();
        while (!sr.EndOfStream)
        {
            // Each line is split into an array and added to the lists in parallel
            string? line = sr.ReadLine();
            string[] arr = string.IsNullOrEmpty(line) ? [] : line.Split(',');
            // UInt64.Parse is used to convert the ID string to an integer for math later
            ids.Add(UInt64.Parse(arr[0]));
            names.Add(arr[1]);
            descriptions.Add(arr[2]);
            species.Add(arr[3]);
            firstAppearances.Add(arr[4]);
            yearsCreated.Add(arr[5]);
        }
        sr.Close();
    }
    // Catch exceptions
    catch (Exception e)
    {
        logger.Error(e.Message);
    }

    // menu options
    do
    {
        Console.WriteLine("1) Display all characters.");
        Console.WriteLine("2) Add a character.");
        Console.WriteLine("Enter any other key to exit.");

        // input response, if not 1 or 2, exit
        choice = Console.ReadLine();

        // log user choice
        logger.Info("User choice: {0}", choice);

        if (choice == "1")
        {
            // display all characters
            for (int i = 0; i < ids.Count; i++)
            {
                Console.WriteLine("ID: {0}", ids[i]);
                Console.WriteLine("Name: {0}", names[i]);
                Console.WriteLine("Description: {0}", descriptions[i]);
                Console.WriteLine("Species: {0}", species[i]);
                Console.WriteLine("First Appearance: {0}", firstAppearances[i]);
                Console.WriteLine("Year Created: {0}", yearsCreated[i]);
                Console.WriteLine();
            }
        }
        // add a character
        else if (choice == "2")
        {
            // id generated by adding 1 to the max id in the list
            UInt64 id = ids.Count > 0 ? ids.Max() + 1 : 1;
            // prompt for name
            Console.WriteLine("Name?");
            string? name = Console.ReadLine();
            // more exception handling
            if (!string.IsNullOrEmpty(name))
            {
                // makes a new list of lower case names to check for duplicates
                // .. is the range operator that was suggested by the compiler
                List<string> lowerCaseNames = [.. names.Select(n => n.ToLower())];
                if (lowerCaseNames.Contains(name.ToLower()))
                {
                    logger.Info("Duplicate name: {0}", name);
                }
                else
                {
                    // prompt for other character details, these can be nullable here, we handle it later
                    Console.WriteLine("Description?");
                    string? desc = Console.ReadLine();
                    Console.WriteLine("Species?");
                    string? spec = Console.ReadLine();
                    Console.WriteLine("First Appearance?");
                    string? fApp = Console.ReadLine();
                    Console.WriteLine("Year Created?");
                    string? yCtd = Console.ReadLine();

                    // New character is added to lists here since the csv file is only read once at the top.
                    ids.Add(id);
                    names.Add(name);
                    // ?? is the null coalescing operator that replaced my ternary for null checking
                    // It returns the left-hand operand if the operand is not null; otherwise it returns the right hand operand.
                    descriptions.Add(desc ?? "");
                    species.Add(spec ?? "");
                    firstAppearances.Add(fApp ?? "");
                    yearsCreated.Add(yCtd ?? "");

                    // write new character to file
                    StreamWriter sw = new(file, append: true);
                    sw.WriteLine("{0},{1},{2},{3},{4},{5}", id, name, desc, spec, fApp, yCtd);
                    sw.Close();

                    logger.Info("Character added - ID: {0}, Name: {1}", id, name);
                }
            }
            else
            {
                logger.Error("Error: Name cannot be empty");
            }
        }

    } while (choice == "1" || choice == "2");
}

logger.Info("Program ended");
